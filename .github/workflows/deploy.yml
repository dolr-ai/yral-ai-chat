name: Deploy

on:
  push:
    branches:
      - main
      - staging

jobs:
  deploy:
    name: Deploy ${{ github.ref_name == 'main' && 'Production' || 'Staging' }}
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.HETZNER_BARE_METAL_GITHUB_ACTIONS_SSH_PRIVATE_KEY }}
      
      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.DEPLOY_HOST }} >> ~/.ssh/known_hosts
      
      - name: Set deployment variables
        id: vars
        run: |
          if [ "${{ github.ref_name }}" == "main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "service=yral-ai-chat" >> $GITHUB_OUTPUT
            echo "branch=main" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "service=yral-ai-chat-staging" >> $GITHUB_OUTPUT
            echo "branch=staging" >> $GITHUB_OUTPUT
          fi
      
      - name: Create .env file
        run: |
          cat > .env << 'EOF'
          # Application Settings
          APP_NAME=${{ secrets.APP_NAME || 'Yral AI Chat API' }}
          APP_VERSION=${{ secrets.APP_VERSION || '1.0.0' }}
          ENVIRONMENT=${{ steps.vars.outputs.environment }}
          DEBUG=${{ secrets.DEBUG || 'False' }}
          
          # Database
          DATABASE_PATH=${{ secrets.DATABASE_PATH || '/app/data/yral_chat.db' }}
          
          # JWT Authentication
          JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY }}
          JWT_ALGORITHM=${{ secrets.JWT_ALGORITHM || 'HS256' }}
          JWT_ISSUER=${{ secrets.JWT_ISSUER || 'yral_auth' }}
          
          # Google Gemini API
          GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}
          GEMINI_MODEL=${{ secrets.GEMINI_MODEL || 'gemini-2.5-flash' }}
          GEMINI_MAX_TOKENS=${{ secrets.GEMINI_MAX_TOKENS || '2048' }}
          GEMINI_TEMPERATURE=${{ secrets.GEMINI_TEMPERATURE || '0.7' }}
          
          # Media Storage
          MAX_IMAGE_SIZE_MB=${{ secrets.MAX_IMAGE_SIZE_MB || '10' }}
          MAX_AUDIO_SIZE_MB=${{ secrets.MAX_AUDIO_SIZE_MB || '20' }}
          MAX_AUDIO_DURATION_SECONDS=${{ secrets.MAX_AUDIO_DURATION_SECONDS || '300' }}
          
          # S3 Configuration
          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_S3_BUCKET=${{ secrets.AWS_S3_BUCKET }}
          AWS_REGION=${{ secrets.AWS_REGION || 'us-east-1' }}
          S3_ENDPOINT_URL=${{ secrets.S3_ENDPOINT_URL }}
          S3_PUBLIC_URL_BASE=${{ secrets.S3_PUBLIC_URL_BASE }}
          
          # Whisper API (Optional)
          USE_WHISPER=${{ secrets.USE_WHISPER || 'false' }}
          WHISPER_API_KEY=${{ secrets.WHISPER_API_KEY || '' }}
          
          # CORS Configuration
          CORS_ORIGINS=${{ secrets.CORS_ORIGINS || '*' }}
          CORS_ALLOW_CREDENTIALS=${{ secrets.CORS_ALLOW_CREDENTIALS || 'true' }}
          
          # Rate Limiting
          RATE_LIMIT_PER_MINUTE=${{ secrets.RATE_LIMIT_PER_MINUTE || '60' }}
          RATE_LIMIT_PER_HOUR=${{ secrets.RATE_LIMIT_PER_HOUR || '1000' }}
          
          # Logging
          LOG_LEVEL=${{ secrets.LOG_LEVEL || 'INFO' }}
          LOG_FORMAT=${{ secrets.LOG_FORMAT || 'json' }}
          
          # Litestream Configuration
          ENABLE_LITESTREAM=${{ secrets.ENABLE_LITESTREAM || 'true' }}
          LITESTREAM_ACCESS_KEY_ID=${{ secrets.LITESTREAM_ACCESS_KEY_ID }}
          LITESTREAM_SECRET_ACCESS_KEY=${{ secrets.LITESTREAM_SECRET_ACCESS_KEY }}
          LITESTREAM_BUCKET=${{ secrets.LITESTREAM_BUCKET }}
          LITESTREAM_ENDPOINT=${{ secrets.LITESTREAM_ENDPOINT }}
          LITESTREAM_REGION=${{ secrets.LITESTREAM_REGION }}
          EOF
      
      - name: Copy .env file to server
        run: |
          scp -o StrictHostKeyChecking=no .env ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}:/root/yral-ai-chat/.env
          rm .env
      
      - name: Deploy to server
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} << EOF
            set -e
            
            ENVIRONMENT="${{ steps.vars.outputs.environment }}"
            SERVICE="${{ steps.vars.outputs.service }}"
            BRANCH="${{ steps.vars.outputs.branch }}"
            
            cd /root/yral-ai-chat
            
            echo "üì• Pulling latest code from \$BRANCH branch..."
            git fetch origin
            git checkout \$BRANCH
            git pull origin \$BRANCH
            
            echo "üîç Validating nginx configuration..."
            docker run --rm \
              -v \$(pwd)/nginx/yral-ai-chat.conf:/etc/nginx/conf.d/default.conf:ro \
              -v /etc/letsencrypt:/etc/letsencrypt:ro \
              nginx:alpine nginx -t
            
            echo "üõë Stopping old services..."
            systemctl stop yral-ai-chat.service 2>/dev/null || true
            systemctl disable yral-ai-chat.service 2>/dev/null || true
            
            # Only stop and rebuild the specific service we're deploying
            echo "üèóÔ∏è  Building Docker image for \$ENVIRONMENT..."
            docker compose build --no-cache \$SERVICE
            
            echo "üöÄ Starting/updating \$ENVIRONMENT service..."
            docker compose up -d \$SERVICE
            
            # Ensure nginx is running (restart if needed)
            docker compose up -d nginx
            
            echo "‚è≥ Waiting for service to start..."
            sleep 15
            
            echo "üóÑÔ∏è  Running database migrations for \$ENVIRONMENT..."
            docker compose exec -T \$SERVICE python scripts/run_migrations.py || {
              echo "‚ùå \$ENVIRONMENT migrations failed!"
              docker compose logs --tail=50 \$SERVICE
              exit 1
            }
            
            echo "üîÑ Restarting service to load migrated data..."
            docker compose restart \$SERVICE
            
            echo "‚è≥ Waiting for service to restart..."
            sleep 10
            
            echo "üè• Running health checks for \$ENVIRONMENT..."
            check_health() {
              local service=\$1
              local port=8000
              local max_attempts=15
              local attempt=1
              
              while [ \$attempt -le \$max_attempts ]; do
                if docker compose exec -T \$service python -c "import urllib.request; urllib.request.urlopen('http://localhost:\$port/health')" 2>/dev/null; then
                  echo "‚úÖ \$service health check passed!"
                  return 0
                fi
                
                if [ \$attempt -eq \$max_attempts ]; then
                  echo "‚ùå \$service health check failed after \$max_attempts attempts"
                  docker compose logs --tail=100 \$service
                  return 1
                fi
                
                echo "   \$service: Attempt \$attempt/\$max_attempts... retrying in 3s"
                sleep 3
                attempt=\$((attempt + 1))
              done
            }
            
            check_health \$SERVICE || exit 1
            
            echo ""
            echo "‚úÖ \$ENVIRONMENT deployment complete!"
            echo "üìä Service status:"
            docker compose ps \$SERVICE
            echo ""
            echo "üìã Recent logs:"
            docker compose logs --tail=20 \$SERVICE
          EOF
