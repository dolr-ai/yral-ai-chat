name: Deploy to Production

on:
  push:
    branches:
      - main

jobs:
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DEPLOY_SSH_KEY }}
      
      - name: Add server to known hosts
        run: |
          ssh-keyscan -H ${{ secrets.DEPLOY_HOST }} >> ~/.ssh/known_hosts
      
      - name: Deploy to server
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          APP_NAME: ${{ secrets.APP_NAME }}
          APP_VERSION: ${{ secrets.APP_VERSION }}
          ENVIRONMENT: ${{ secrets.ENVIRONMENT }}
          DEBUG: ${{ secrets.DEBUG }}
          DATABASE_PATH: ${{ secrets.DATABASE_PATH }}
          JWT_ALGORITHM: ${{ secrets.JWT_ALGORITHM }}
          JWT_ISSUER: ${{ secrets.JWT_ISSUER }}
          GEMINI_MODEL: ${{ secrets.GEMINI_MODEL }}
          GEMINI_MAX_TOKENS: ${{ secrets.GEMINI_MAX_TOKENS }}
          GEMINI_TEMPERATURE: ${{ secrets.GEMINI_TEMPERATURE }}
          MEDIA_UPLOAD_DIR: ${{ secrets.MEDIA_UPLOAD_DIR }}
          MEDIA_BASE_URL: ${{ secrets.MEDIA_BASE_URL }}
          MAX_IMAGE_SIZE_MB: ${{ secrets.MAX_IMAGE_SIZE_MB }}
          MAX_AUDIO_SIZE_MB: ${{ secrets.MAX_AUDIO_SIZE_MB }}
          MAX_AUDIO_DURATION_SECONDS: ${{ secrets.MAX_AUDIO_DURATION_SECONDS }}
          USE_S3: ${{ secrets.USE_S3 }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          S3_ENDPOINT: ${{ secrets.S3_ENDPOINT }}
          USE_WHISPER: ${{ secrets.USE_WHISPER }}
          WHISPER_API_KEY: ${{ secrets.WHISPER_API_KEY }}
          CORS_ORIGINS: ${{ secrets.CORS_ORIGINS }}
          CORS_ALLOW_CREDENTIALS: ${{ secrets.CORS_ALLOW_CREDENTIALS }}
          RATE_LIMIT_PER_MINUTE: ${{ secrets.RATE_LIMIT_PER_MINUTE }}
          RATE_LIMIT_PER_HOUR: ${{ secrets.RATE_LIMIT_PER_HOUR }}
          LOG_LEVEL: ${{ secrets.LOG_LEVEL }}
          LOG_FORMAT: ${{ secrets.LOG_FORMAT }}
        run: |
          ssh ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} << 'ENDSSH'
            set -e
            
            cd /root/yral-ai-chat
            
            # Pull latest code
            echo "üì• Pulling latest code..."
            git pull origin main
            
            # Stop systemd service if running (migrating to Docker)
            echo "üõë Stopping systemd service (if running)..."
            systemctl stop yral-ai-chat.service 2>/dev/null || true
            systemctl disable yral-ai-chat.service 2>/dev/null || true
            
            # Build and deploy with secrets
            echo "üöÄ Building and deploying with Docker..."
            JWT_SECRET_KEY="$JWT_SECRET_KEY" \
            GEMINI_API_KEY="$GEMINI_API_KEY" \
            APP_NAME="${APP_NAME:-Yral AI Chat API}" \
            APP_VERSION="${APP_VERSION:-1.0.0}" \
            ENVIRONMENT="${ENVIRONMENT:-production}" \
            DEBUG="${DEBUG:-False}" \
            DATABASE_PATH="${DATABASE_PATH:-/app/data/yral_chat.db}" \
            JWT_ALGORITHM="${JWT_ALGORITHM:-HS256}" \
            JWT_ISSUER="${JWT_ISSUER:-yral_auth}" \
            GEMINI_MODEL="${GEMINI_MODEL:-gemini-2.5-flash}" \
            GEMINI_MAX_TOKENS="${GEMINI_MAX_TOKENS:-2048}" \
            GEMINI_TEMPERATURE="${GEMINI_TEMPERATURE:-0.7}" \
            MEDIA_UPLOAD_DIR="${MEDIA_UPLOAD_DIR:-/app/uploads}" \
            MEDIA_BASE_URL="${MEDIA_BASE_URL:-http://localhost:8000/media}" \
            MAX_IMAGE_SIZE_MB="${MAX_IMAGE_SIZE_MB:-10}" \
            MAX_AUDIO_SIZE_MB="${MAX_AUDIO_SIZE_MB:-20}" \
            MAX_AUDIO_DURATION_SECONDS="${MAX_AUDIO_DURATION_SECONDS:-300}" \
            USE_S3="${USE_S3:-false}" \
            AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID:-}" \
            AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY:-}" \
            AWS_S3_BUCKET="${AWS_S3_BUCKET:-}" \
            AWS_REGION="${AWS_REGION:-us-east-1}" \
            S3_ENDPOINT="${S3_ENDPOINT:-}" \
            USE_WHISPER="${USE_WHISPER:-false}" \
            WHISPER_API_KEY="${WHISPER_API_KEY:-}" \
            CORS_ORIGINS="${CORS_ORIGINS:-*}" \
            CORS_ALLOW_CREDENTIALS="${CORS_ALLOW_CREDENTIALS:-true}" \
            RATE_LIMIT_PER_MINUTE="${RATE_LIMIT_PER_MINUTE:-60}" \
            RATE_LIMIT_PER_HOUR="${RATE_LIMIT_PER_HOUR:-1000}" \
            LOG_LEVEL="${LOG_LEVEL:-INFO}" \
            LOG_FORMAT="${LOG_FORMAT:-json}" \
            docker-compose up -d --build
            
            # Wait for service to be ready
            echo "‚è≥ Waiting for service to start..."
            sleep 10
            
            # Run database migrations if needed
            echo "üóÑÔ∏è  Checking database migrations..."
            if [ -f "migrations/sqlite/001_init_schema.sql" ]; then
              # Check if database exists
              if [ ! -f "data/yral_chat.db" ]; then
                echo "   Creating database and running migrations..."
                docker-compose exec -T yral-ai-chat python scripts/run_migrations.py || echo "   ‚ö†Ô∏è  Migration may have already been applied"
              else
                echo "   ‚úÖ Database already exists"
                echo "   ‚ÑπÔ∏è  To run migrations on existing database, use: docker-compose exec yral-ai-chat python scripts/run_migrations.py"
              fi
            else
              echo "   ‚ö†Ô∏è  Migration files not found, skipping"
            fi
            echo ""
            
            # Health check
            echo "üè• Running health check..."
            max_attempts=10
            attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              if curl -f -s http://localhost:8000/health > /dev/null 2>&1; then
                echo "‚úÖ Health check passed"
                break
              else
                if [ $attempt -eq $max_attempts ]; then
                  echo "‚ùå Health check failed after $max_attempts attempts"
                  docker-compose logs --tail=50 yral-ai-chat
                  exit 1
                else
                  echo "   Attempt $attempt/$max_attempts..."
                  sleep 3
                  attempt=$((attempt + 1))
                fi
              fi
            done
            
            echo "‚úÖ Deployment complete!"
            docker-compose ps
          ENDSSH
