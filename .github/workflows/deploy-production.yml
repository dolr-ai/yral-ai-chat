name: Deploy Production

on:
  push:
    branches:
      - main

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-dev.txt
      
      - name: Initialize test database
        env:
          DATABASE_PATH: ${{ github.workspace }}/data/test.db
        run: |
          mkdir -p data
          python scripts/run_migrations.py
          echo "Database initialized at: $DATABASE_PATH"
          ls -la data/ || true
      
      - name: Run tests
        env:
          DATABASE_PATH: ${{ github.workspace }}/data/test.db
          JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
          JWT_ALGORITHM: HS256
          JWT_ISSUER: yral_auth
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
          AWS_REGION: ${{ secrets.AWS_REGION || 'us-east-1' }}
          S3_ENDPOINT_URL: ${{ secrets.S3_ENDPOINT_URL }}
          S3_PUBLIC_URL_BASE: ${{ secrets.S3_PUBLIC_URL_BASE }}
          ENVIRONMENT: development
        run: |
          pytest -v --tb=short

  deploy:
    name: Deploy Production
    runs-on: ubuntu-latest
    needs: test  # Only deploy if tests pass
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.HETZNER_BARE_METAL_GITHUB_ACTIONS_SSH_PRIVATE_KEY }}
      
      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.DEPLOY_HOST }} >> ~/.ssh/known_hosts
      
      - name: Create .env file
        run: |
          cat > .env << 'EOF'
          # Application Settings
          APP_NAME=${{ secrets.APP_NAME || 'Yral AI Chat API' }}
          APP_VERSION=${{ secrets.APP_VERSION || '1.0.0' }}
          ENVIRONMENT=production
          DEBUG=${{ secrets.DEBUG || 'False' }}
          
          # Database
          DATABASE_PATH=${{ secrets.DATABASE_PATH || '/app/data/yral_chat.db' }}
          
          # JWT Authentication
          JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY }}
          JWT_ALGORITHM=${{ secrets.JWT_ALGORITHM || 'HS256' }}
          JWT_ISSUER=${{ secrets.JWT_ISSUER || 'yral_auth' }}
          
          # Google Gemini API
          GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}
          GEMINI_MODEL=${{ secrets.GEMINI_MODEL || 'gemini-2.5-flash' }}
          GEMINI_MAX_TOKENS=${{ secrets.GEMINI_MAX_TOKENS || '2048' }}
          GEMINI_TEMPERATURE=${{ secrets.GEMINI_TEMPERATURE || '0.7' }}
          
          # Media Storage
          MAX_IMAGE_SIZE_MB=${{ secrets.MAX_IMAGE_SIZE_MB || '10' }}
          MAX_AUDIO_SIZE_MB=${{ secrets.MAX_AUDIO_SIZE_MB || '20' }}
          MAX_AUDIO_DURATION_SECONDS=${{ secrets.MAX_AUDIO_DURATION_SECONDS || '300' }}
          
          # S3 Configuration
          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_S3_BUCKET=${{ secrets.AWS_S3_BUCKET }}
          AWS_REGION=${{ secrets.AWS_REGION || 'us-east-1' }}
          S3_ENDPOINT_URL=${{ secrets.S3_ENDPOINT_URL }}
          S3_PUBLIC_URL_BASE=${{ secrets.S3_PUBLIC_URL_BASE }}
          
          # Whisper API (Optional)
          USE_WHISPER=${{ secrets.USE_WHISPER || 'false' }}
          WHISPER_API_KEY=${{ secrets.WHISPER_API_KEY || '' }}
          
          # CORS Configuration
          CORS_ORIGINS=${{ secrets.CORS_ORIGINS || '*' }}
          CORS_ALLOW_CREDENTIALS=${{ secrets.CORS_ALLOW_CREDENTIALS || 'true' }}
          
          # Rate Limiting
          RATE_LIMIT_PER_MINUTE=${{ secrets.RATE_LIMIT_PER_MINUTE || '60' }}
          RATE_LIMIT_PER_HOUR=${{ secrets.RATE_LIMIT_PER_HOUR || '1000' }}
          
          # Logging
          LOG_LEVEL=${{ secrets.LOG_LEVEL || 'INFO' }}
          LOG_FORMAT=${{ secrets.LOG_FORMAT || 'json' }}
          
          # Litestream Configuration
          ENABLE_LITESTREAM=${{ secrets.ENABLE_LITESTREAM || 'true' }}
          LITESTREAM_ACCESS_KEY_ID=${{ secrets.LITESTREAM_ACCESS_KEY_ID }}
          LITESTREAM_SECRET_ACCESS_KEY=${{ secrets.LITESTREAM_SECRET_ACCESS_KEY }}
          LITESTREAM_BUCKET=${{ secrets.LITESTREAM_BUCKET }}
          LITESTREAM_ENDPOINT=${{ secrets.LITESTREAM_ENDPOINT }}
          LITESTREAM_REGION=${{ secrets.LITESTREAM_REGION }}
          EOF
      
      - name: Copy .env file to server
        run: |
          scp -o StrictHostKeyChecking=no .env ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}:/root/yral-ai-chat/.env
          rm .env
      
      - name: Deploy to server
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} << 'DEPLOY_SCRIPT'
            set -e
            
            ENVIRONMENT="production"
            SERVICE="yral-ai-chat"
            BRANCH="main"
            PROJECT_DIR="/root/yral-ai-chat"
            HEALTH_CHECK_PORT=8000
            HEALTH_CHECK_MAX_ATTEMPTS=15
            HEALTH_CHECK_RETRY_DELAY=3
            SERVICE_START_DELAY=15
            SERVICE_RESTART_DELAY=10
            
            cd "$PROJECT_DIR"
            
            # Set environment variable for docker-compose
            export PRODUCTION_ENV=production
            
            # Helper function: Check service health
            check_service_health() {
              local service_name=$1
              local port=$2
              local max_attempts=$3
              local retry_delay=$4
              local attempt=1
              
              echo "[INFO] Starting health check for $service_name on port $port"
              
              while [ $attempt -le $max_attempts ]; do
                echo "[INFO] Health check attempt $attempt/$max_attempts for $service_name"
                
                # Check if container is running
                if ! docker compose -f docker-compose.prod.yml ps "$service_name" | grep -q "Up"; then
                  echo "[ERROR] Container $service_name is not running"
                  docker compose -f docker-compose.prod.yml ps "$service_name"
                  docker compose -f docker-compose.prod.yml logs --tail=50 "$service_name"
                  return 1
                fi
                
                # Try health check
                if docker compose -f docker-compose.prod.yml exec -T "$service_name" python -c \
                  "import urllib.request; urllib.request.urlopen('http://localhost:$port/health')" \
                  2>&1; then
                  echo "[OK] $service_name health check passed"
                  return 0
                else
                  echo "[WARN] Health check failed, checking container logs..."
                  docker compose -f docker-compose.prod.yml logs --tail=20 "$service_name"
                fi
                
                if [ $attempt -eq $max_attempts ]; then
                  echo "[ERROR] $service_name health check failed after $max_attempts attempts"
                  echo "[ERROR] Container status:"
                  docker compose -f docker-compose.prod.yml ps "$service_name"
                  echo "[ERROR] Full container logs:"
                  docker compose -f docker-compose.prod.yml logs --tail=200 "$service_name"
                  echo "[ERROR] Checking if process is running inside container:"
                  docker compose -f docker-compose.prod.yml exec -T "$service_name" ps aux || true
                  echo "[ERROR] Checking if port is listening:"
                  docker compose -f docker-compose.prod.yml exec -T "$service_name" netstat -tlnp 2>/dev/null || docker compose -f docker-compose.prod.yml exec -T "$service_name" ss -tlnp 2>/dev/null || echo "Cannot check ports"
                  return 1
                fi
                
                echo "[INFO] $service_name: Attempt $attempt/$max_attempts failed, retrying in ${retry_delay}s"
                sleep $retry_delay
                attempt=$((attempt + 1))
              done
            }
            
            # Step 1: Update code from repository
            echo "[INFO] Pulling latest code from $BRANCH branch"
            git fetch origin
            # Discard any local changes and reset branch to match remote exactly
            git checkout -B "$BRANCH" "origin/$BRANCH"
            
            # Step 2: Validate nginx configuration
            echo "[INFO] Validating nginx configuration"
            docker run --rm \
              -v "$(pwd)/nginx/rate-limit-zones.conf:/etc/nginx/conf.d/rate-limit-zones.conf:ro" \
              -v "$(pwd)/nginx/yral-ai-chat.conf:/etc/nginx/conf.d/default.conf:ro" \
              -v "$(pwd)/nginx/nginx.conf.wrapper:/etc/nginx/nginx.conf:ro" \
              -v /etc/letsencrypt:/etc/letsencrypt:ro \
              nginx:alpine nginx -t
            
            # Step 3: Stop legacy systemd service if exists
            echo "[INFO] Stopping legacy systemd service"
            systemctl stop yral-ai-chat.service 2>/dev/null || true
            systemctl disable yral-ai-chat.service 2>/dev/null || true
            
            # Step 4: Build Docker image
            echo "[INFO] Building Docker image for $ENVIRONMENT"
            docker compose -f docker-compose.prod.yml build --no-cache "$SERVICE"
            
            # Step 5: Start service
            echo "[INFO] Starting $ENVIRONMENT service"
            docker compose -f docker-compose.prod.yml up -d "$SERVICE"
            
            # Show container status immediately
            echo "[INFO] Container status after start:"
            docker compose -f docker-compose.prod.yml ps "$SERVICE" || true
            
            # Show initial logs
            echo "[INFO] Initial container logs:"
            docker compose -f docker-compose.prod.yml logs --tail=50 "$SERVICE" || true
            
            # Step 6: Start Metabase production service
            echo "[INFO] Starting Metabase production service"
            docker compose -f docker-compose.prod.yml up -d metabase || echo "[WARN] Metabase production container may already be running"
            
            # Show Metabase production container status
            echo "[INFO] Metabase production container status:"
            docker compose -f docker-compose.prod.yml ps metabase || true
            
            # Show Metabase production initial logs
            echo "[INFO] Metabase production initial logs:"
            docker compose -f docker-compose.prod.yml logs --tail=30 metabase || true
            
            # Wait a moment for Metabase to start accepting connections
            echo "[INFO] Waiting 10s for Metabase production to initialize..."
            sleep 10
            
            # Test if Metabase production is responding
            echo "[INFO] Testing Metabase production health..."
            if curl -f http://localhost:3000/api/health > /dev/null 2>&1; then
              echo "[OK] Metabase production is ready"
            else
              echo "[WARN] Metabase production may still be initializing (this is normal, can take up to 60s)"
            fi
            
            # Step 7: Start nginx (without starting dependencies to avoid affecting staging)
            echo "[INFO] Starting nginx"
            docker compose -f docker-compose.prod.yml up -d --no-deps nginx
            
            # Step 7.5: Restart nginx to ensure it picks up the latest config
            echo "[INFO] Restarting nginx to load latest configuration"
            docker compose -f docker-compose.prod.yml restart nginx
            
            # Wait for nginx container to be fully running
            echo "[INFO] Waiting for nginx container to be ready..."
            max_wait=10
            wait_count=0
            while [ $wait_count -lt $max_wait ]; do
              if docker ps --filter "name=yral-ai-chat-nginx" --filter "status=running" --format "{{.Names}}" | grep -q yral-ai-chat-nginx; then
                sleep 2  # Give it a moment to fully initialize
                break
              fi
              sleep 1
              wait_count=$((wait_count + 1))
            done
            
            # Step 7.6: Verify nginx config is valid and reloaded
            echo "[INFO] Verifying nginx configuration"
            if docker exec yral-ai-chat-nginx nginx -t > /dev/null 2>&1; then
              echo "[OK] Nginx configuration is valid"
              # Try graceful reload first
              if docker exec yral-ai-chat-nginx nginx -s reload > /dev/null 2>&1; then
                echo "[OK] Nginx configuration reloaded successfully"
              else
                echo "[WARN] Nginx reload failed, container was restarted above"
              fi
            else
              echo "[ERROR] Nginx configuration test failed"
              docker exec yral-ai-chat-nginx nginx -t || true
              echo "[WARN] Continuing despite nginx test failure (container was restarted)"
            fi
            
            # Step 8: Wait for service to start
            echo "[INFO] Waiting ${SERVICE_START_DELAY}s for service to start"
            sleep $SERVICE_START_DELAY
            
            # Show logs again after wait
            echo "[INFO] Container logs after ${SERVICE_START_DELAY}s wait:"
            docker compose -f docker-compose.prod.yml logs --tail=50 "$SERVICE" || true
            
            # Step 9: Run database migrations
            echo "[INFO] Running database migrations for $ENVIRONMENT"
            echo "[INFO] Container logs before migrations:"
            docker compose -f docker-compose.prod.yml logs --tail=30 "$SERVICE" || true
            if ! docker compose -f docker-compose.prod.yml exec -T "$SERVICE" python scripts/run_migrations.py 2>&1; then
              echo "[ERROR] $ENVIRONMENT migrations failed"
              echo "[ERROR] Container logs after migration failure:"
              docker compose -f docker-compose.prod.yml logs --tail=100 "$SERVICE"
              exit 1
            fi
            echo "[INFO] Migrations completed successfully"
            
            # Step 10: Restart service to load migrated data
            echo "[INFO] Restarting service to load migrated data"
            docker compose -f docker-compose.prod.yml restart "$SERVICE"
            echo "[INFO] Waiting ${SERVICE_RESTART_DELAY}s for service to restart"
            sleep $SERVICE_RESTART_DELAY
            
            # Show logs after restart
            echo "[INFO] Container logs after restart:"
            docker compose -f docker-compose.prod.yml logs --tail=50 "$SERVICE" || true
            
            # Step 11: Health check
            echo "[INFO] Running health checks for $ENVIRONMENT"
            if ! check_service_health "$SERVICE" "$HEALTH_CHECK_PORT" "$HEALTH_CHECK_MAX_ATTEMPTS" "$HEALTH_CHECK_RETRY_DELAY"; then
              exit 1
            fi
            
            # Step 12: Metabase health checks
            echo "[INFO] Checking Metabase services..."
            if curl -f http://localhost:3000/api/health > /dev/null 2>&1; then
              echo "[OK] Metabase (production) service is healthy"
            else
              echo "[WARN] Metabase (production) service health check failed (may still be initializing)"
            fi
            
            if curl -f http://localhost:3001/api/health > /dev/null 2>&1; then
              echo "[OK] Metabase (staging) service is healthy"
            else
              echo "[WARN] Metabase (staging) service health check failed (may still be initializing)"
            fi
            
            # Verify nginx can reach Metabase production
            echo "[INFO] Verifying nginx can reach Metabase production..."
            if docker exec yral-ai-chat-nginx wget -q -O- http://127.0.0.1:3000/api/health > /dev/null 2>&1; then
              echo "[OK] Nginx container can reach Metabase production on port 3000"
            else
              echo "[WARN] Nginx container cannot reach Metabase production on port 3000"
            fi
            
            # Step 13: Final connectivity tests
            echo "[DEBUG] Final connectivity tests:"
            echo "[DEBUG] Testing production health from host:"
            curl -v http://127.0.0.1:8000/health 2>&1 | head -20 || echo "Failed"
            echo "[DEBUG] Testing staging health from host:"
            curl -v http://127.0.0.1:8001/health 2>&1 | head -20 || echo "Failed"
            echo "[DEBUG] Testing via nginx (if accessible):"
            curl -k -v https://127.0.0.1/health 2>&1 | head -20 || curl -v http://127.0.0.1/health 2>&1 | head -20 || echo "Cannot test via nginx"
            
            # Step 14: Deployment summary
            echo ""
            echo "[SUCCESS] $ENVIRONMENT deployment complete"
            echo "[INFO] Service status:"
            docker compose -f docker-compose.prod.yml ps "$SERVICE"
            echo ""
            echo "[INFO] All services:"
            docker compose -f docker-compose.prod.yml ps
            echo ""
            echo "[INFO] Recent logs:"
            docker compose -f docker-compose.prod.yml logs --tail=20 "$SERVICE"
            echo ""
            echo "üåê Services available at:"
            echo "   - Production API: http://localhost:8000"
            echo "   - Staging API: http://localhost:8001"
            echo "   - Metabase (Production): https://chat.yral.com/metabase/"
            echo "   - Metabase (Staging): https://chat.yral.com/staging/metabase/"
          DEPLOY_SCRIPT
